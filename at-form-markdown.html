<script src="scripts/prettify.js"></script>
<script src="scripts/Markdown.js"></script>
<script src="scripts/Markdown.Editor.js"></script>
<script src="scripts/Markdown.Extra.js"></script>
<script src="scripts/markdown-inline-attachment.js"></script>
<script src="scripts/markdown-input.inline-attachment.js"></script>

<link rel="import" href="markdown-default-converter.html"/>
<link rel="import" href="markdown-sanitizing-decorator/markdown-sanitizing-decorator.html"/>
<link rel="import" href="../tangere/tangere.html">
<link rel="import" href="../at-i18n/at-i18n-behavior.html">
<link rel="import" href="../at-form-behaviors/at-form-behaviors-validation.html">
<link rel="import" href="../at-theme/at-theme.html">
<link rel="import" href="../at-carbon-icon-button/at-carbon-icon-button.html">
<link rel="import" href="styles/at-form-markdown-styles.html">
<link rel="import" href="styles/prettify-styles.html">
<!--
    at-form-markdown is a polymer component for markdown markup
    @properties
      inlineAttachmentUploadUrl - url for uploading meda (eg. images)
      inlineAttachmentJsonFieldName - the name of the field in response which contains the filenanme of the uploaded file
      inlineAttachmentExtraParams - extra parameters that will be sent with each request in request body

    @components used
        markdown-default-converter
            - this component is a client side converter based on polymer marked-element; when no other is supplied via shadow insertion ponit this one is used as default

    @usage
        <at-form-markdown></at-form-markdown> somewhere on the page

    @why is this this way?
        @font-face polymer has issues with @font-face and solution here is how that issue is solved. you add a style tag with @font-face declaration and call it a day
        component has html structure for text editing and preview, default converter and shadow insertion point
        inline-attachment code is merged into the component and feature is initialized in place
        since this component is based on original orchard markdown editor that code is more or less unchanged and resides in *.js files above

        personally I dislike how inline-attachment is currently implemented - I think hooks should be used, but that needs additional time to figure out
-->

<dom-module id="at-form-markdown">
  <template>
    <style include="at-form-common"></style>
    <style include="at-form-markdown-styles"></style>
    <style include="prettify-styles"></style>
    <style>
      #buttonToolbar[disabled] {
        pointer-events: none;
      }

      #wmdInput[disabled] {
        pointer-events: none;
      }

      .button-toolbar {
        display: inline-block;
      }
      .button-toolbar.hidden {
        display: none;
      }

    </style>
    <div id="atContainer" class="at-container">
      <iron-label id="label">{{label}}</iron-label>
      <div id="contentContainer" class="wmd-box at-content-container" onload="prettyPrint()">
        <div class="wmd-innerbox">
          <div id="buttonToolbar">
            <div id="editToolbar" class="button-toolbar">
              <at-carbon-icon-button id="btnBold" icon="now:bold" class="carbon-icon-button"></at-carbon-icon-button>
              <at-carbon-icon-button id="btnItalic" icon="now:italic" class="carbon-icon-button"></at-carbon-icon-button>
              <at-carbon-icon-button id="btnLink" icon="now:link" class="carbon-icon-button"></at-carbon-icon-button>
              <at-carbon-icon-button id="btnQuote" icon="now:quote" class="carbon-icon-button"></at-carbon-icon-button>
              <at-carbon-icon-button id="btnCode" icon="now:code" class="carbon-icon-button"></at-carbon-icon-button>
              <at-carbon-icon-button id="btnImage" icon="now:picture" class="carbon-icon-button"></at-carbon-icon-button>
              <at-carbon-icon-button id="btnOlist" icon="now:list-numbered" class="carbon-icon-button"></at-carbon-icon-button>
              <at-carbon-icon-button id="btnUlist" icon="now:list-bullets" class="carbon-icon-button"></at-carbon-icon-button>
              <at-carbon-icon-button id="btnHeading" icon="now:heading" class="carbon-icon-button"></at-carbon-icon-button>
              <at-carbon-icon-button id="btnUndo" icon="now:undo" class="carbon-icon-button"></at-carbon-icon-button>
              <at-carbon-icon-button id="btnRedo" icon="now:redo" class="carbon-icon-button"></at-carbon-icon-button>
              <at-carbon-icon-button id="btnPreview" icon="now:visible" class="carbon-icon-button"></at-carbon-icon-button>
              <at-carbon-icon-button id="btnHelp" icon="now:help" class="carbon-icon-button"></at-carbon-icon-button>
            </div>
            <div id="previewToolbar" class="button-toolbar hidden">
              <at-carbon-icon-button id="btnHidePreview" icon="now:edit" class="carbon-icon-button"></at-carbon-icon-button>
            </div>
            <div id="serviceToolbar" class="button-toolbar">
              <at-carbon-icon-button id="btnToggleFullscreen" icon="now:expand" class="carbon-icon-button"></at-carbon-icon-button>
            </div>
          </div>
          <div class="wmd-editor-box">
            <textarea id="wmdInput" name$="{{name}}" rows="7" cols="80" class="wmd-input at-content"></textarea>
            <div id="markdownBottomText">
              <div id="chromeText" style="display: none">Attach images by dragging and dropping,
                <a id="chromeTextLink" href="javascript:void(0)">selecting them</a>, or pasting from the clipboard.</div>
              <div id="nonChromeText" style="display: none">Attach images by dragging and dropping or
                <a id="nonChromeTextLink" href="javascript:void(0)">selecting them</a>.</div>
              <div style="display: none">
                <input id="fileInput" type="file"/>
              </div>
            </div>
          </div>
          <div class="wmd-preview-box" style="display: none">
            <div id="wmdPreview" class="wmd-panel wmd-preview"></div>
          </div>
        </div>
        <content id="shadow"></content>
      </div>
      <div id="hint"></div>
    </div>
  </template>
</dom-module>
<script>
  "use strict";

  window.isFunction = function (obj) {
    return Object.prototype.toString.call(obj) === "[object Function]";
  }

  Polymer({
    is: 'at-form-markdown',
    behaviors: [
      Tangere.behaviors.formValidation, Tangere.behaviors.i18n
    ],
    _instanceVariables: {
      converter: undefined,
      mediaPicker: undefined
    },
    properties: {
      value: {
        type: String,
        value: '',
        observer: 'valueChanged',
        xtype: "textarea",
        title: 'Value'
      },
      inlineAttachmentExtraParams: {
        type: Object,
        value: function () {
          return {};
        },
        observer: 'inlineAttachmentExtraParamsChanged'
      },
      inlineAttachmentUploadUrl: {
        type: String,
        value: '',
        observer: 'inlineAttachmentUploadUrlChanged'
      },
      inlineAttachmentJsonFieldName: {
        type: String,
        value: '',
        observer: 'inlineAttachmentJsonFieldNameChanged'
      },
      disabled: {
        type: Boolean,
        value: false,
        observer: 'disabledChanged',
        title: 'Field value can not be changed'
      },
      required: {
        type: Boolean,
        value: false,
        observer: 'requiredChanged',
        title: 'Input requred'
      },
      label: {
        type: String,
        value: '',
        title: 'Label'
      },
      hideLabel: {
        type: Boolean,
        value: false,
        observer: 'hideLabelChanged'
      },
      /**
       * Hides the element. When hidden nothing is displayed for the element
       * @property hide
       * @type Boolean
       * @default false
       */
      hide: {
        type: Boolean,
        value: false,
        observer: 'hideChanged',
        title: 'Field is invisible'
      }
    },
    $meta: [
      {
        title: "Markdown",
        type: "string",
        xtype: "marked"
      }
    ],
    hideChanged: function (newValue, oldValue) {
      var atContainer = this.$.atContainer;
      this.toggleClass('hidden', newValue, atContainer);
      if (this._isReady) {
        this.validate();
      }
    },
    hideLabelChanged: function (newValue, oldValue) {
      this.toggleClass("hidden", newValue, this.$.label);
    },
    ready: function (event) {
      this._isReady = false;
      // 1) Look at the shadow distributed nodes and find instances of converter and media picker instances
      var shadowDistributedNodes = Polymer.dom(this.$.shadow).getDistributedNodes();
      // find the converter
      this._instanceVariables.mediaPicker = undefined;
      for (var i = 0; i < shadowDistributedNodes.length; i++) {
        var node = shadowDistributedNodes[i];
        // *ij* subject to change but it makes sense that
        if (node.id === "converter" // id of the element be "converter" && node._converterInstance !== undefined // element should have a _converterInstance variable && isFunction(node._converterInstance.makeHtml) // and _converterInstance should have makeHtml function
        ) {
          this._instanceVariables.converter = node._converterInstance;
        }
        if (node.id === "mediaPicker" && isFunction(node.addHooks)) {
          this._instanceVariables.mediaPicker = node;
        }
      }

      // if desired converter was not set as textContent of the at-form-markdown create everything programatically since declarative doesn't work in IE

      var defaultConverter = document.createElement('markdown-default-converter');
      // default converter doesn't have any configuration

      var sanitizingDecorator = document.createElement('markdown-sanitizing-decorator');
      // a converter instance of sanitizing converter needs to be set to default converter
      sanitizingDecorator._converterInstance = defaultConverter._converterInstance;
      this._instanceVariables.converter = sanitizingDecorator._converterInstance;

      var converter = this._instanceVariables.converter;

      // 2) initialize the Markdown.Extra
      Markdown.Extra.init(converter, {
        extensions: "all",
        highlighter: "prettify"
      });

      // 3) instantiate the Markdown.Editor
      var panelsCollection = {
        buttonBar: this.$.buttonToolbar,
        editToolbar: this.$.editToolbar,
        previewToolbar: this.$.previewToolbar,
        serviceToolbar: this.$.serviceToolbar,
        preview: this.$.wmdPreview,
        input: this.$.wmdInput
      };

      var editor = new Markdown.Editor(converter, {
        handler: function () {
          window.open("http://daringfireball.net/projects/markdown/syntax");
        }
      }, panelsCollection, this.shadowRoot || this.shadyRoot);

      // 4) init the mediapicker hooks
      if (this._instanceVariables.mediaPicker !== undefined) {
        this._instanceVariables.mediaPicker.addHooks(editor, this.$.wmdInput);
      }

      // 5) initialize inline attachment plugin
      this._initializeInlineAttachment();

      // 6) initialize the footer text
      this.__initializeBottomText();

      // 7) setup the autoGrow function
      Markdown.autoGrow(this.$.wmdInput);

      // 8) initialize google code prettify
      editor.hooks.chain("onPreviewRefresh", prettyPrint); // google code prettify

      // 9) run the editor
      editor.run();

      // 10) attach to wmdInput chage event to update component value
      var self = this;
      var inputProvider = this.$.wmdInput;
      this.$.wmdInput.addEventListener('change', function (e) {
        var newValue = inputProvider.value;
        self.value = newValue;
        self.validate();
        self._fireValueChangedEvent(newValue);
      });

      this._isReady = true;
    },
    focus: function () {
      var valueProvider = this.$.wmdInput;
      valueProvider.focus();
    },
    valueChanged: function (newValue, oldValue) {
      this.$.wmdInput.value = newValue;
      if (this._isReady) {
        this.validate();
        this._fireValueChangedEvent(newValue);
      }
    },
    _fireValueChangedEvent: function (newValue) {
      this.fire('value-changed', {value: newValue});
    },
    _updateUIValidState: function (isValid) {
      this.toggleClass('error', !isValid, this.$.label);
      this.toggleClass('error', !isValid, this.$.contentContainer);
      this.toggleClass('error', !isValid, this.$.hint);
    },
    disabledChanged: function (newValue, oldValue) {
      var atContainer = this.$.atContainer;
      this.toggleClass('disabled', newValue, atContainer);

      if (this.disabled) {
        this.$.buttonToolbar.setAttribute('disabled', 'true');
        this.$.wmdInput.setAttribute('disabled', 'true');
        this.$.wmdInput.setAttribute('tabIndex', -1);
      } else {
        this.$.buttonToolbar.removeAttribute('disabled');
        this.$.wmdInput.removeAttribute('disabled');
        this.$.wmdInput.removeAttribute('tabIndex');
      }
      if (this._isReady) {
        this.validate();
      }
    },
    requiredChanged: function (newValue, oldValue) {
      if (this._isReady) {
        this.validate();
      }
    },
    _getFocusableElement: function () {
      return this.$.wmdInput;
    },
    inlineAttachmentUploadUrlChanged: function (oldValue, newValue) {
      if (!this._isReady) {
        return;
      }
      this._initializeInlineAttachment();
      this.__initializeBottomText();
      this._inlineAttachmentInstance.settings.uploadUrl = this.inlineAttachmentUploadUrl;
    },
    inlineAttachmentJsonFieldNameChanged: function (oldValue, newValue) {
      if (!this._isReady) {
        return;
      }
      if (this._inlineAttachmentInstance !== undefined) {
        this._inlineAttachmentInstance.settings.jsonFieldName = this.inlineAttachmentJsonFieldName;
      }
    },
    inlineAttachmentExtraParamsChanged: function (oldValue, newValue) {
      if (!this._isReady) {
        return;
      }
      if (this._inlineAttachmentInstance !== undefined) {
        this._inlineAttachmentInstance.settings.extraParams = this.inlineAttachmentExtraParams;
      }
    },
    _initializeInlineAttachment: function () {
      if (this.inlineAttachmentUploadUrl === undefined || this.inlineAttachmentUploadUrl === '') {
        return;
      }
      var _self = this;

      this._inlineAttachmentInstance = inlineAttachment.editors.input.attachToInput(this.$.wmdInput, {
        uploadUrl: this.inlineAttachmentUploadUrl,
        jsonFieldName: this.inlineAttachmentJsonFieldName,
        onFileUploadResponse: function (xhr) {
          var result = JSON.parse(xhr.responseText),
            filename = result[0][this.settings.jsonFieldName];

          if (result && filename) {
            var newValue = this.settings.urlText.replace(this.filenameTag, filename);
            newValue = newValue.replace(this.originalNameTag, this.settings.originalName);
            var text = this.editor.getValue().replace(this.lastValue, newValue);
            this.editor.setValue(text);
          }

          var keypressEvent = document.createEvent('Event');
          keypressEvent.initEvent('keypress', true, true);
          _self.$.wmdInput.dispatchEvent(keypressEvent);

          return true;
        },
        setupFormData: function (formData, file) {
          // *ij* here "this" is the inline-attachment settings object
          var originalName = this.originalName;
          if (file.name != undefined && file.name.indexOf(".") > -1) {
            var fileNameParts = file.name.split('.');
            originalName = fileNameParts[0];
          }

          this.originalName = originalName;
        },
        extraParams: this.inlineAttachmentExtraParams
      });
    },

    /*
     * initializes the text at the bottom of the component
     */
    __initializeBottomText: function (event) {
      var fileInput = this.$.fileInput;
      var textArea = this.$.wmdInput;

      if (this.inlineAttachmentUploadUrl === undefined || this.inlineAttachmentUploadUrl === '') {
        if (window.chrome !== undefined) {
          var chromeText1 = this.$.chromeText;
          chromeText1.style.display = "none";
        } else {
          var nonChromeText1 = this.$.nonChromeText;
          nonChromeText1.style.display = "none";
        }
        return;
      }

      if (window.chrome !== undefined) {
        // browser is google chrome
        var chromeText = this.$.chromeText;
        chromeText.style.display = "block";
        var chromeTextLink = this.$.chromeTextLink;
        chromeTextLink.addEventListener('click', function (e) {
          fileInput.click();
          e.preventDefault();
        }, false);
      } else {
        // its some other browser
        var nonChromeText = this.$.nonChromeText;
        nonChromeText.style.display = "block";
        var nonChromeTextLink = this.$.nonChromeTextLink;
        nonChromeTextLink.addEventListener('click', function (e) {
          fileInput.click();
          e.preventDefault();
        }, false);
      }

      fileInput.addEventListener('change', function (e) {
        e.preventDefault();
        var dropEvent = document.createEvent('Event');
        dropEvent.initEvent('drop', true, true);
        dropEvent.dataTransfer = {};
        dropEvent.dataTransfer.files = e.target.files;
        textArea.dispatchEvent(dropEvent);
      });
    }
  });
</script>
